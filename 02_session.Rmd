---
title: "Tuesday session notes"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Summary

Today we'll get an introduction to the tidyverse. Which includes reading in data, and reshaping it, recoding it, and merging data together. 

# Read in the births data

Tidy data (our objective) is defined as a tabular arrangement of data, where columns are strictly variables and rows consist in single observations.

```{r}
# packages we'll need
# install.packages("here")
library(tidyverse)
library(readxl)
library(here)
Wide <- read_excel(path = here("Data", "demo_fasec.xlsx"),
           range = "A10:H158")
glimpse(Wide)
```

`pivot_longer()` collects a range of columns and stacks them. `names_to` is where the previous columns names get collected in a new column. `values_to` is where the cell values are collected as a single column.
```{r}
Long <-
   pivot_longer(data = Wide,
                cols = 3:8,
                names_to = "TIME",
                values_to = "Births")
Long
```

The column range can be specified by name too, or also using various kinds of conditional selection. In the second example it chooses all columns where the data type is `double`.

```{r}
# select using column name range
 pivot_longer(data = Wide,
                cols = `2011`:`2016`,
                names_to = "TIME",
                values_to = "Births")

 pivot_longer(data = Wide,
                cols = where(is.double),
                names_to = "TIME",
                values_to = "Births")
```

Select and rename columns to whatever standard we want. When we assign to `Long` having started with `Long`, it overwrites the old one.
```{r}
Long <- 
  select(.data = Long,
       Country = `GEO/TIME`,
       Age = AGE,
       Year = TIME,
       Births)
glimpse(Long)
```

Now let's redo the above three steps making use of piping. `%>%` Ctrl + Shift + m

```{r}
Long <-
# step 1, read it in
  read_excel(
    path = here("Data", "demo_fasec.xlsx"),
    range = "A10:H158") %>% 
  
# step 2, stack the years
  pivot_longer(
    cols = `2011`:`2016`,
    names_to = "Year",
    values_to = "Births"
  ) %>% 
  
# step 3 select and rename columns the way we want
  select(
    Country = `GEO/TIME`,
    Year,
    Age = AGE,
    Births)
```

Now let's recode `Age`

```{r}
Long %>% 
  pull(Age) %>% 
  unique()
```
First, to demonstrate the processing steps on a single subset of the data, then do it for all subsets at once!!
```{r}
library(readr)
# example so you understand logical selection
  # Long %>% 
  # mutate(my_selector = Country == "Czechia" & Year == "2011") %>% 
  # filter(my_selector) %>% 
  # mutate(TOT = Births[Age == "Total"])

# but this way is better!
 Long %>% 
   
   # select subset for this example to demonstrate the logic of it
  filter(Country == "Czechia",
         Year == "2011") %>% 
   
   # move Total births up to a column
  mutate(TOT = Births[Age == "Total"]) %>% 
   
   # now we can throw out Total and Unknown ages
  filter(!Age %in% c("Total","Unknown")) %>% 
   
   # redistribute births with known age of mother
   # so that they add up to the total!
  mutate(Fraction = Births / sum(Births),
         Births = TOT * Fraction,
         
         # pick out the integer part of age from the character strings
         Age = parse_number(Age)) %>% 
   
   # remove temporary / instrumental columns
  select(-TOT, -Fraction) 
```


Mini time out to understand logicals and how they can be used to select things in `R`:

```{r}
a <- rnorm(10)
a[a >= 0]
my_selector <- a >= 0
a[!my_selector]
```

Time to do this for all the subsets at once!

```{r}
Births <-
# step 1, read it in
  read_excel(
    path = here("Data", "demo_fasec.xlsx"),
    range = "A10:H158") %>% 
  
# step 2, stack the years
  pivot_longer(
    cols = `2011`:`2016`,
    names_to = "Year",
    values_to = "Births"
  ) %>% 
  
# step 3 select and rename columns the way we want
  select(
    Country = `GEO/TIME`,
    Year,
    Age = AGE,
    Births) %>% 
   
  # step 4 declare groups on each unique combination of Country and Year
  # that is present in these data. This creates independent groups!
  group_by(Country, Year) %>% 

   # 5 move Total births up to a column
  mutate(TOT = Births[Age == "Total"]) %>% 
   
   # 6 now we can throw out Total and Unknown ages
  filter(!Age %in% c("Total","Unknown")) %>% 
   
   # 7 redistribute births with known age of mother
   # so that they add up to the total!
  mutate(Fraction = Births / sum(Births),
         Births = TOT * Fraction,
         
         # pick out the integer part of age from the character strings
         Age = parse_number(Age)) %>% 
   
   # 8 remove temporary / instrumental columns
  select(-TOT, -Fraction) %>% 
  
  # 9 remove the groups!
  ungroup()
```


# Calculating summary measures

To calculate summary measures (including tabulations) we use `summarize()` (`summarise()`), just be sure to declare groups, if appropriate! And don't forget to remove them when done!
```{r}
# The data are clean, let's calculate something!
MAB <-
  Births %>% 
  
  # apply groups
  group_by(Country, Year) %>% 
  
  # define the summary measure
  summarize(MAB = sum(Age * Births) / sum(Births) + .5,
            # remove unneeded groups
            .groups = "drop")
```














