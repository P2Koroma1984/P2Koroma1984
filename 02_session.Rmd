---
title: "Tuesday session notes"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Summary

Today we'll get an introduction to the tidyverse. Which includes reading in data, and reshaping it, recoding it, and merging data together. 

# Read in the births data

Tidy data (our objective) is defined as a tabular arrangement of data, where columns are strictly variables and rows consist in single observations.

```{r}
# packages we'll need
# install.packages("here")
library(tidyverse)
library(readxl)
library(here)
Wide <- read_excel(path = here("Data", "demo_fasec.xlsx"),
           range = "A10:H158")
glimpse(Wide)
```

`pivot_longer()` collects a range of columns and stacks them. `names_to` is where the previous columns names get collected in a new column. `values_to` is where the cell values are collected as a single column.
```{r}
Long <-
   pivot_longer(data = Wide,
                cols = 3:8,
                names_to = "TIME",
                values_to = "Births")
Long
```

The column range can be specified by name too, or also using various kinds of conditional selection. In the second example it chooses all columns where the data type is `double`.

```{r}
# select using column name range
 pivot_longer(data = Wide,
                cols = `2011`:`2016`,
                names_to = "TIME",
                values_to = "Births")

 pivot_longer(data = Wide,
                cols = where(is.double),
                names_to = "TIME",
                values_to = "Births")
```

Select and rename columns to whatever standard we want. When we assign to `Long` having started with `Long`, it overwrites the old one.
```{r}
Long <- 
  select(.data = Long,
       Country = `GEO/TIME`,
       Age = AGE,
       Year = TIME,
       Births)
glimpse(Long)
```

Now let's redo the above three steps making use of piping. `%>%` Ctrl + Shift + m

```{r}
Long <-
# step 1, read it in
  read_excel(
    path = here("Data", "demo_fasec.xlsx"),
    range = "A10:H158") %>% 
  
# step 2, stack the years
  pivot_longer(
    cols = `2011`:`2016`,
    names_to = "Year",
    values_to = "Births"
  ) %>% 
  
# step 3 select and rename columns the way we want
  select(
    Country = `GEO/TIME`,
    Year,
    Age = AGE,
    Births)
```

Now let's recode `Age`

```{r}
Long %>% 
  pull(Age) %>% 
  unique()
```
First, to demonstrate the processing steps on a single subset of the data, then do it for all subsets at once!!
```{r}
library(readr)
# example so you understand logical selection
  # Long %>% 
  # mutate(my_selector = Country == "Czechia" & Year == "2011") %>% 
  # filter(my_selector) %>% 
  # mutate(TOT = Births[Age == "Total"])

# but this way is better!
 Long %>% 
   
   # select subset for this example to demonstrate the logic of it
  filter(Country == "Czechia",
         Year == "2011") %>% 
   
   # move Total births up to a column
  mutate(TOT = Births[Age == "Total"]) %>% 
   
   # now we can throw out Total and Unknown ages
  filter(!Age %in% c("Total","Unknown")) %>% 
   
   # redistribute births with known age of mother
   # so that they add up to the total!
  mutate(Fraction = Births / sum(Births),
         Births = TOT * Fraction,
         
         # pick out the integer part of age from the character strings
         Age = parse_number(Age)) %>% 
   
   # remove temporary / instrumental columns
  select(-TOT, -Fraction) 
```


Mini time out to understand logicals and how they can be used to select things in `R`:

```{r}
a <- rnorm(10)
a[a >= 0]
my_selector <- a >= 0
a[!my_selector]
```

Time to do this for all the subsets at once!

```{r}
Births <-
# step 1, read it in
  read_excel(
    path = here("Data", "demo_fasec.xlsx"),
    range = "A10:H158") %>% 
  
# step 2, stack the years
  pivot_longer(
    cols = `2011`:`2016`,
    names_to = "Year",
    values_to = "Births"
  ) %>% 
  
# step 3 select and rename columns the way we want
  select(
    Country = `GEO/TIME`,
    Year,
    Age = AGE,
    Births) %>% 
   
  # step 4 declare groups on each unique combination of Country and Year
  # that is present in these data. This creates independent groups!
  group_by(Country, Year) %>% 

   # 5 move Total births up to a column
  mutate(TOT = Births[Age == "Total"]) %>% 
   
   # 6 now we can throw out Total and Unknown ages
  filter(!Age %in% c("Total","Unknown")) %>% 
   
   # 7 redistribute births with known age of mother
   # so that they add up to the total!
  mutate(Fraction = Births / sum(Births),
         Births = TOT * Fraction,
         
         # pick out the integer part of age from the character strings
         Age = parse_number(Age)) %>% 
   
   # 8 remove temporary / instrumental columns
  select(-TOT, -Fraction) %>% 
  
  # 9 remove the groups!
  ungroup()
```


# Calculating summary measures

To calculate summary measures (including tabulations) we use `summarize()` (`summarise()`), just be sure to declare groups, if appropriate! And don't forget to remove them when done!
```{r}
# The data are clean, let's calculate something!
MAB <-
  
  # the incoming data object, Births
  Births %>% 
  
  # apply groups
  group_by(Country, Year) %>% 
  
  # define the summary measure
  summarize(MAB = sum(Age * Births) / sum(Births) + .5,
            # remove unneeded groups
            .groups = "drop")
```


# Process denominators

First, read the data in, be sure to declare the `NA` character, `":"`
```{r}
Pop <-
  
  # First read in a cell range from the spreadsheet
  read_excel(path = here("Data", "demo_pjan.xlsx"),
           range = "A10:CZ510",
           # this time it's necessary to declare the NA code
           na = ":") %>% 
  
  pivot_longer(cols = `Less than 1 year`:`Unknown`,
              names_to = "Age",
              values_to = "Population") %>% 
  
  filter(!is.na(Population))
```

Recode age classes:

```{r}
Pop %>% 
  pull(Age) %>% 
  unique()
```

We'll use `parse_number()` just like before
```{r}
Pop <-
  
  # incoming population data
  Pop %>% 
  
  # recode age, accounting for all cases, assinging NA to Unknown
  mutate(Age = case_when(
    Age == "Less than 1 year" ~ 0,
    Age == "Open-ended age class" ~ 100,
    Age == "Unknown" ~ NA_real_,
    TRUE ~ parse_number(Age)
  )) %>% 
  
  # select the columns we want to keep and rename as needed
  select(Country = `GEO/AGE`,
         Year = TIME,
         Age,
         Population)
```

Demonstrate `case_when()`
```{r}
x <- 0:20
abc <- letters[1:21]
x %% 2
x %% 2 == 0
case_when(x %% 3 == 0 ~ "Maybe tomorrow will be better",
          x %% 2 == 0 ~ "Today is a good day",
          TRUE ~ "Tomorrow for sure excellent")
```

Now we should redistribute population counts with unknown age, proportional to those of known age.

`ifelse(logical, TRUE, FALSE)`
```{r}
Pop <-
  Pop %>% 
  
  group_by(Country, Year) %>% 
  
  mutate(UNK = Population[is.na(Age)],
         # fills created NAs with 0s, because missing Unknowns
         # just means that there were none
         UNK = ifelse(is.na(UNK), 0, UNK)) %>% 
  
  # throw out the NA ages (unknowns)
  filter(!is.na(Age)) %>% 
  
  # redistribution as a 1-liner,
  # Population / sum(Population) is what we called Fraction before
  mutate(Population = Population + Population / sum(Population) * UNK,
         Year = as.integer(Year)) %>% 
  
  # remove groups no longer needed
  ungroup() %>% 
  
  # remove unneeded column
  select(-UNK)
```


Calculate exposures

```{r}
Pop <-
# incoming population data
  Pop %>% 
  
  # move Year back by one so that it becomes
  # Dec 31
  mutate(Year = Year - 1) %>% 
  
  # rename to P2 so we dont get confused
  rename(P2 = Population) %>% 
  
  # join back to P1, STRICTLY, only overlapping cases
  inner_join(Pop, by = c("Country", "Year","Age")) %>% 
  
  # call that one P1
  rename(P1 = Population) %>% 
  
  # Calulate Exposure approximation
  mutate(Exposure = (P1 + P2) / 2)
```

















